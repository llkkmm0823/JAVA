package days11;


//일반(상속관계가 없는) 객체의 생성과정
// 1. 멤버변수들을 Heap메모리에 로딩, 생성
// 2. 생성자 메서드를 호출

// 상속관계 있는 객체(자식객체)의 생성과정
// 1. 멤버변수들을 Heap 메모리에 로딩. 		생성 -> 부모/자식 클래스의 모든 멤버변수를 한 번에 생성
// 2. 자식 클래스 객체가 생성되는 것이므로 자식클래스의 생성자가 먼저 호출됨
// 3. 자식 클래스의 생성자의 첫 번째 실행코드가 부모클래스의 생성자를 호출
// 		ㄴ자식클래스의 생성자 명령 중 첫 줄이 부모클래스의 생성자 호출이라는 뜻
// 		ㄴ자식 클래스 생성자 명령 첫 줄은 super(); 라는 명령이며, 따로 기술하지않아도 존재하는 명령
// 		ㄴ디폴트 생성자처럼 꺼내서 직접 쓰기 전까지는 숨어있는 명령
// 4. 부모클래스 생성자를 모두 실행한 후 자식 클래스 생성자의 남은 명령을 실행
//  	ㄴ구조가 이렇게 짜여진 이유: 부모클래스의 private 멤버를 자식 클래스의 생성자에서 초기화 할 수 없음.
//  									     부모클래스 생성자를 통해 접근하고 초기화하기 위함

class SuperB{
	int superNum;
	SuperB(){
		System.out.println("부모클래스의 생성자 실행");
	}
}
class SubB extends SuperB{
	int subNum;
	//생성자를 별도로 꺼내서 정의하지 않았다면?
	// SubB(){ super(); } 이와 같은 생성자와 명령이 숨어 있는 것과 같음
	
	//생성자를 별도로 꺼내서 정의한 경우 super() 명령 외에 다른 명령도 쓸 수 있음
	SubB(){
		super(); // 써도 되고 안써도 되는데 맨 첫번째로 호출되는 놈
		// 부모클래스 생성자가 자식 클래스 생성자에서 첫 번째 명령으로 호출됨
		// 생략되어도 동일하게 호출됨
		// 자식 클래스에서 부모클래스 생성자 호출은 super();라고 명령, 반드시 ' 첫 번째 실행코드 '로 씁니다
		// super();코드는 생략 가능
		System.out.println("자식클래스의 생성자 실행");
	}
}

public class Extends04 {

	public static void main(String[] args) {

		 SubB b= new SubB();
	
	}

}
